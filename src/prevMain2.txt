#include <iostream>
#include <vector>

#include "../include/DataGeneration/lodepng.h"
#include "../include/DataGeneration/ImageGenerator.h"
#include "../include/DataGeneration/Spiral.h"

#include "../include/Layers/Dense.h"
#include "../include/Layers/Dropout.h"

#include "../include/ActivationFunctions/ReLu.h"
#include "../include/ActivationFunctions/Softmax.h"
#include "../include/ActivationFunctions/Sigmoid.h"

#include "../include/LossFunctions/CategoricalCrossEntropy.h"
#include "../include/LossFunctions/SoftmaxCategoricalCrossEntropy.h"
#include "../include/LossFunctions/BinaryCrossEntropy.h"

#include "../include/Optimizers/SGD.h"
#include "../include/Optimizers/Adagrad.h"
#include "../include/Optimizers/RMSProp.h"
#include "../include/Optimizers/Adam.h"

using namespace std;
using Eigen::MatrixXd;
using Eigen::VectorXd;
using Eigen::VectorXi;
using Eigen::RowVectorXd;
using namespace std::chrono;

// auto start = high_resolution_clock::now();

// auto stop = high_resolution_clock::now();
// auto duration = duration_cast<microseconds>(stop - start);
// std::cout << duration.count() << std::endl;

int main() {
    srand(1);

    Spiral dataset(100, 2);
    MatrixXd X = dataset.getX();
    MatrixXd Y = dataset.getY();

    Dense dense1 = Dense(2, 64, 0.0, 0.0, 5e-4, 5e-4);
    ReLu activation1 = ReLu();
    Dense dense2 = Dense(64, 1);
    Sigmoid activation2 = Sigmoid();
    BinaryCrossEntropy lossFunction = BinaryCrossEntropy();

    Adam optimizer = Adam(0.1, 5e-7);
    
    double loss, dataLoss, regularizationLoss;
    MatrixXd outputs;
    VectorXd predictions = VectorXd::Zero(200);
    int matchCount;
    // Eigen::Index maxRow;
    for(int epoch = 0; epoch < 10001; epoch++){

        // auto start = high_resolution_clock::now();
        // FORWARD PASS
        dense1.forward(&X);
        activation1.forward(dense1.getOutput());
        dense2.forward(activation1.getOutput());
        activation2.forward(dense2.getOutput());
        lossFunction.forward(activation2.getOutput(), &Y);

        dataLoss = lossFunction.calculate(activation2.getOutput(), &Y);
        regularizationLoss = lossFunction.calculateRegularizationLoss(&dense1)
                            + lossFunction.calculateRegularizationLoss(&dense2);
        loss = dataLoss + regularizationLoss;

        // ACCURACY CALCULATION
        outputs = *(activation2.getOutput());
        matchCount = 0;
        for(int rowIndex = 0; rowIndex < outputs.rows(); rowIndex++) {
            if((outputs(rowIndex, 0) > 0.5 && Y(rowIndex, 0) == 1) || (outputs(rowIndex, 0) <= 0.5 && Y(rowIndex, 0) == 0)) {
                matchCount++;
            }
        }

        // BACKPROPAGATION
        lossFunction.backward(activation2.getOutput(), &Y);
        activation2.backward(lossFunction.getDinputs());
        dense2.backward(activation2.getDinputs());
        activation1.backward(dense2.getDinputs());
        dense1.backward(activation1.getDinputs());

        // PARAMETER UPDATE
        optimizer.decay();
        optimizer.updateParameters(&dense1);
        optimizer.updateParameters(&dense2);
        optimizer.incrementIteration();

        // auto stop = high_resolution_clock::now();
        // auto duration = duration_cast<microseconds>(stop - start);

        if((epoch % 100) == 0) {
            cout << "Epoch: " << epoch << "\t";
            cout << "Loss: " << loss << "\t";
            cout << "Data loss: " << dataLoss << "\t";
            cout << "Regularization loss: " << regularizationLoss << "\t";
            cout << "Accuracy: " << (double) matchCount / Y.rows() << endl;
            // cout << optimizer.getLearningRate() << endl;
            // std::cout << duration.count() << std::endl;
        }
    }

    //////////////////////////////////////////////////////////////////////
    ///////////////////////////// TEST DATA //////////////////////////////

    Spiral test(100, 2);
    MatrixXd XTest = test.getX();
    MatrixXd YTest = test.getY();

    dense1.forward(&X);
    activation1.forward(dense1.getOutput());
    dense2.forward(activation1.getOutput());
    activation2.forward(dense2.getOutput());
    lossFunction.forward(activation2.getOutput(), &Y);
    
    dataLoss = lossFunction.calculate(activation2.getOutput(), &Y);
    regularizationLoss = lossFunction.calculateRegularizationLoss(&dense1)
                        + lossFunction.calculateRegularizationLoss(&dense2);
    loss = dataLoss + regularizationLoss;

    outputs = *(activation2.getOutput());
    matchCount = 0;
    for(int rowIndex = 0; rowIndex < outputs.rows(); rowIndex++) {
        if((outputs(rowIndex, 0) > 0.5 && Y(rowIndex, 0) == 1) || (outputs(rowIndex, 0) <= 0.5 && Y(rowIndex, 0) == 0)) {
            matchCount++;
        }
    }

    cout << "Test Data: \t Loss: " << loss << "\t";
    cout << "Accuracy: " << (double) matchCount / Y.rows() << endl;
    cout << optimizer.getLearningRate() << endl;
    
    //////////////////////////////////////////////////////////////////////////
    ///////////////////////////// VISUALIZATION //////////////////////////////
    const int WIDTH = 1000;
    const int HEIGHT = 1000;
    MatrixXd inputGrid = MatrixXd(WIDTH * HEIGHT, 2);
    for(int y = 0; y < HEIGHT; y++) {
        for(int x = 0; x < WIDTH; x++) {
            inputGrid((y * HEIGHT) + x, 0) = (x * 2.0 / WIDTH) - 1;
            inputGrid((y * HEIGHT) + x, 1) = (y * 2.0 / HEIGHT) - 1;
        }
    }

    dense1.forward(&inputGrid);
    activation1.forward(dense1.getOutput());
    dense2.forward(activation1.getOutput());
    activation2.forward(dense2.getOutput());

    std::vector<unsigned char> pixels(WIDTH * HEIGHT * 4); // RGBA format
    double pix;
    for (int y = 0; y < HEIGHT; ++y) {
        for (int x = 0; x < WIDTH; ++x) {
            int index = 4 * (y * WIDTH + x);
            pix = (*(activation2.getOutput()))(y * HEIGHT + x, 0);
            // green: 109, 209, 129
            // red: 255, 130, 130
            pixels[index + 0] = sqrt(109 * 109 * pix + 255 * 255 * (1 - pix));
            pixels[index + 1] = sqrt(209 * 209 * pix + 130 * 130 * (1 - pix));
            pixels[index + 2] = sqrt(129 * 129 * pix + 130 * 130 * (1 - pix));
            pixels[index + 3] = 255; // Alpha channel (opacity: 255 = fully opaque)
        }
    }
    ImageGenerator gen = ImageGenerator();
    gen.createImage(pixels, "visualizations/adam/binaryCrossEntropylr0.01dr5e-7.png", WIDTH, HEIGHT);

    return 0;
}